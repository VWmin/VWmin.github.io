---
title: Golang
tag:
  - Golang
---

<!--more-->

## 起步

### 配置GOPATH

go项目的存放路径

![1609730844373](../assets/2021-01-04-Go.assets/1609730844373.png)

默认创建了= =

如果更改，PATH里`.../go/bin`也对应修改

### 项目

程序以package为单位，以`package main`中的`func main()`为入口

## 语法

### 导入

```go
import (
	"fmt"
	"math"
)
```

```go
import f "fmt"
func main() {
	f.Println(add(42, 13)) //重命名标识符
}
```



### 函数

```go
func add(x int, y int) int {
	return x + y
}
```

```go
func add(x, y int) int { //省略连续的相同类型
	return x + y
}
```

```go
func swap(x, y string) (string, string) { //多值返回
	return y, x
}
```

```go
func split(sum int) (x, y int) { //相当于提前定义了要返回的值的名称
	x = sum * 4 / 9
	y = sum - x
	return //不带命名的return语句 将会直接返回上面定义了名称的返回值
}
```

### 变量

```go
var a, b, c bool //声明了三个bool类型的变量
//声明可以出现在任何位置
func main() {
	var i int //声明的变量具有默认值
	fmt.Println(i, a, b, c)
}
```

```go
var i, j int = 1, 2 //声明变量的同时初始化

func main() {
	var a b, c = true, false, "no!" //变量可以从初始化中获得类型
	fmt.Println(i, j, a, b, c)
}
```

```c++
k := 3 //简洁赋值语句 代替var
//函数外的每个语句都必须以关键字开始（var, func 等等），因此 := 结构不能在函数外使用。
```

```go
func test(x int) int  {
	return x
}

func main() {
	x := 1.2
	fmt.Println(test(int(x))) //不同类型赋值需要显式转换
}
```

### 常量

```go
//与var相对的 声明常量使用关键字const
const Pi = 3.14
// 常量不能用 := 声明
```

### 循环、分支

```go
func main() {
	sum := 0
	for i := 0; i < 10; i++ {
		sum += i
	}
	fmt.Println(sum)
}
```

```go
func main() {
	sum := 1
	for sum < 1000 { //Golang中的while
		sum += sum
	}
	fmt.Println(sum)
}
```

```go
if x < 0 { //分支

} else {
    
}
```

```go
func pow(x, n, lim float64) float64 {
	if v := math.Pow(x, n); v < lim { //在分支判断的前面执行一个表达式
		return v
	}
	return lim
}
```

```go
func main() { //switch
	fmt.Print("Go runs on ")
	switch os := runtime.GOOS; os { //没什么好说的吧
	case "darwin":
		fmt.Println("OS X.")
        // break自动提供
	case "linux":
		fmt.Println("Linux.")
	default:
		fmt.Printf("%s.\n", os)
	}
}
```

```go
func main() { // if-else if-...-else
	t := time.Now()
	switch {
	case t.Hour() < 12:
		fmt.Println("Good morning!")
	case t.Hour() < 17:
		fmt.Println("Good afternoon.")
	default:
		fmt.Println("Good evening.")
	}
}
```

```go
//defer关键字

var s string

func getWorld() string {
	s = "world"
	return s
}

func main() {
	defer fmt.Println(getWorld()) //将函数推迟到本层函数执行完毕后执行，但是参数表达式会立即完成
	fmt.Printf("在上面那个函数真正调用之前，其参数表达式已经完成，即调用getWorld()过后，s=%s\n", s)
	fmt.Println("hello")
}
```

```go
func main() {
	fmt.Println("counting")

	for i := 0; i < 10; i++ {
		defer fmt.Println(i) //被defer的函数会被压入一个栈中，依次调用
	}

	fmt.Println("done")
}
```

### 指针

```go
var p *int

i := 42
p = &i

fmt.Println(*p) 
*p = 21         
```

### 结构体

```go
type Vertex struct {
	X int
	Y int
}

func main() {
	a := Vertex{1, 2}
	fmt.Println(a)
}
```

```go
func main() {
	p := &Vertex{1, 2} //声明并初始化一个结构体指针
	p.X = 1e9 //隐式(*p).X
	fmt.Println(v)
}
```

```go
v := Vertex{X: 1}  // 只显式地给部分值 Y:0 被隐式地赋予
```

### 数组

```go
var a [10]int //声明
primes := [6]int{2, 3, 5, 7, 11, 13} //声明并初始化
//类型不可省略
//显式初始化时数量可以省略 省略后是切片（实际上是创建一个数组，然后构建一个引用了它的切片）
//长度不可变
```

### 切片

```go
a[low : high] //前闭后开
```

```go
func main() {
	a := []int{1, 2, 3, 4}
	b := a[0: 2]
	c := a[2: 4]
	fmt.Println(b, c) //切片像是对数组的引用

	for i:=0; i<4; i++{a[i] = 0}
	fmt.Println(b, c) //原数组修改后切片的内容也会改动

	b[0] = -1
	c[0] = -1
	fmt.Println(a) //同样对切片的修改也会引发原数组内容的变化
}
```

```go
/*
切片拥有 长度 和 容量
	    len()   cap()
长度：切片所包含元素的个数
容量：他的第一个元素开始，到被引用的数组的最后一个元素的个数
**/
s := []int{2, 3, 5, 7, 11, 13} //创建一个对长度为6的数组的切片
s = s[:0] //截取切片使其长度为0 长度变化 容量不变
s = s[:4] //拓展其长度 长度变化 容量不变
s = s[2:] //舍弃前两个值 长度变化 容量变化

// 超出容量发生runtimeerro
```

```go
//a := make([]type, len, cap)  用make创建切片（动态数组）
b := make([]int, 0, 5) // len(b)=0, cap(b)=5
```

```go
board := [][]string{
    []string{"_", "_", "_"},
    []string{"_", "_", "_"},
    []string{"_", "_", "_"},
} //二维切片
```

```go
/*
向切片追加新元素
func append(s []T, vs ...T) []T
arg1: 被追加的切片
arg2: 追加进去的元素

当 s 的底层数组太小，不足以容纳所有给定的值时，它就会分配一个更大的数组。返回的切片会指向这个新分配的数组。
**/

func main() {
	var s []int
	printSlice(s)

	// 添加一个空切片
	s = append(s, 0)
	printSlice(s)

	// 这个切片会按需增长
	s = append(s, 1)
	printSlice(s)

	// 可以一次性添加多个元素
	s = append(s, 2, 3, 4)
	printSlice(s)
}
```

```go
//切片遍历
var pow = []int{1, 2, 4, 8, 16, 32, 64, 128}
// pow := []int{...}

func main() {
	for i, v := range pow { //rang pow返回两个值，第一个是下标，第二个数元素副本，不需要的用_代替
		fmt.Printf("2**%d = %d\n", i, v)
	}
}
```

### 映射

```go
//声明一个string到Type的映射
var m map[string]Type
//用make创建一个映射
m = make(map[string]Type)
//声明并初始化一个映射
type Vertex struct {
	Lat, Long float64
}
var m = map[string]Vertex{
	"Bell Labs": Vertex{
		40.68433, -74.39967,
	},
	"Google": Vertex{
		37.42202, -122.08408,
	},
}
//省略类型
var m = map[string]Vertex{
	"Bell Labs": {40.68433, -74.39967},
	"Google":    {37.42202, -122.08408},
}
```

```go
//增、改
m[key] = val
//查
elem = m[key]
//删
delete(m, key)
//检测键是否存在值
elem, ok = m[key]
```

### 函数变量化

函数可以作为变量、参数、返回值进行传递

### 函数的闭包

什么是闭包？存在自由变量的函数就是闭包。

自由变量与约束变量？

```go
func liner(a, b int) func(int) int {
    return func(x int){
        return x * a + b
    }
}
//对于被返回的闭包可以说 x 是受限制的约束变量，a b 是自由变量
//且这个闭包与自由变量a、b是绑定的
```

案例：斐波那契闭包

```go
// 返回一个“返回int的函数”
func fibonacci() func() int {
	x1, x2, i := 1, 1, 0
	return func() int {
		i++
		if i == 1 || i == 2{
			return 1
		}else {
			t := x2
			x2 += x1
			x1 = t
			return x2
		}
	}
}

func main() {
	f := fibonacci()
	for i := 0; i < 10; i++ {
		fmt.Println(f())
	}
}
```

### 方法（带接收者的函数）

接收者能够通过`.`调用这个函数

```go
type Rectangle struct {
	X, Y float64
}

func (v Rectangle) Area() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func main() {
	v := Rectangle{3, 4}
	fmt.Println(v.Area())
}
```

接收者只能是同一个包内定义的类型

```go
func (f float64) Abs() float64 {
	if f < 0 {
		return float64(-f)
	}
	return float64(f)
}//×

type MyFloat float64 
func (f MyFloat) Abs() float64 {
	if f < 0 {
		return float64(-f)
	}
	return float64(f)
}//√
```

方法对接收者的副本进行操作，通过设置指针接收者来使其作用于原本的变量

```go
type Vertex struct {
	X, Y float64
}

func (v *Vertex) Scale(f float64) {
	v.X = v.X * f
	v.Y = v.Y * f
}
```

函数对形参和指针敏感；

指针重定向:

* 指针为接收者的方法的调用对象可以使值也可以是指针，对于值实际上的调用为`(&v).fun()`；- 

* 值为接收者的方法的调用对象可以是值也可以是指针，对于指针实际上的调用为`(*v).fun()`;

### 接口

接口是一组方法签名的集合

```go
//eg
type Abser interface {
	Abs() float64
}
```

```go
//完整实例
type Abser interface {
	Abs() float64
}

func main() {
	var a Abser
	f := MyFloat(-math.Pi)
	v := Vertex{3, 4}

	a = f  // a MyFloat 实现了 Abser
	a = &v // a *Vertex 实现了 Abser

	// 下面一行，v 是一个 Vertex（而不是 *Vertex）
	// 所以没有实现 Abser。
	//a = v 报错

	fmt.Println(a.Abs())
}

type MyFloat float64 //拥有接口中相同签名方法，故被视为Abser的实现

func (f MyFloat) Abs() float64 { //被视为对Abser中Abs()的实现
	if f < 0 {
		return float64(-f)
	}
	return float64(f)
}

type Vertex struct {
	X, Y float64
}

func (v *Vertex) Abs() float64 { //同上
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}
```

类型通过实现一个接口中**所有**方法来**实现该接口**，即使你并没有import那个包，故Go没有`implements`关键字

> 因此，也就无需在每一个实现上增加新的接口名称，这样同时也鼓励了明确的接口定义。

上句，理解不能

**接口可以像值一样传递**，接口值调用方法会调用其具体实现的方法，在内部接口值看做元组`(value, type)`

**接口值可以接受`nil`**，对接收了`nil`的接口调用方法实际上也就是对`nil`尝试引用，会产生空指针异常。但是奇妙的是接收了`nil`的接口本身不为`nil`，所以空指针预防就只能在具体实现的方法中做。

**为`nil`的接口**，可以看成元组是空的，调用产生空指针异常

**空接口** `type interface {}`，因为任何类型都至少实现了0个方法，故空接口用来接收任何类型的值，类似`Object`

```go
type X interface {}
func main() {
	var i X
	describe(i) //(<nil>, <nil>)

	i = 42
	describe(i) //(42, int)

	i = "hello"
	describe(i) //(hello, string)
}

func describe(i X) {
	fmt.Printf("(%v, %T)\n", i, i)
}
```

**类型断言**提供了访问接口值的具体类型的途径

```go
t := i.(T) // 该语句断言接口值i的具体实现是T，并将这个接口值转型具体变量t
```

断言失败会产生`panic`，可通过 `t, ok := i.(T)`获得判断是否断言成功的句柄，且失败不会产生`panic`

**类型选择**，类型断言和`switch`的组合

```go
func do(i interface{}) {
	switch v := i.(type) {
	case int:
		fmt.Printf("Twice %v is %v\n", v, v*2)
	case string:
		fmt.Printf("%q is %v bytes long\n", v, len(v))
	default:
		fmt.Printf("I don't know about type %T!\n", v)
	}
}

func main() {
	do(21)
	do("hello")
	do(true)
}
```

一些特殊的接口：

* `type Stringer interface{ String() string }` 这个接口属于包`fmt`，实现这个方法用以支持许多描述类型的调用

  ```go
  //example
  package main
  
  import "fmt"
  
  type IPAddr [4]byte
  
  // TODO: 给 IPAddr 添加一个 "String() string" 方法
  func (v *IPAddr) String() string {
  	return fmt.Sprintf("%v.%v.%v.%v", v[0], v[1], v[2], v[3])
  }
  
  func main() {
  	hosts := map[string]IPAddr{
  		"loopback":  {127, 0, 0, 1},
  		"googleDNS": {8, 8, 8, 8},
  	}
  	for name, ip := range hosts {
  		fmt.Printf("%v: %v\n", name, ip)
  	}
  }
  ```

* `type error interface{ Error() string }`,这个接口属于内建接口，实现这个接口，来获得错误信息

  ```go
  //example
  package main
  
  import (
  	"fmt"
  	"math"
  )
  
  type ErrNegativeSqrt float64
  
  func (number ErrNegativeSqrt) Error() string {
      //递归调用死循环，由于number实现了Error()，fmt在解释时将其视作error，因此调用了number.Error()，从而出现了递归调用，最终导致栈溢出
      //下意识地准备用引用，麻了
  	//return fmt.Sprintf("cannot Sqrt negative number: %v", number)
      return fmt.Sprintf("cannot Sqrt negative number: %v", float64(number))
  }
  
  func Sqrt(x float64) (float64, error) {
  	if x >= 0 {
  		return math.Sqrt(x), nil
  	}else {
  		return 0, ErrNegativeSqrt(x)
  	}
  }
  
  func main() {
  	fmt.Println(Sqrt(2))
  	fmt.Println(Sqrt(-2))
  }
  ```

  