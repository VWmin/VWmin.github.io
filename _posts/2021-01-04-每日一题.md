---
title: Leetcode - 每日一题
tag:
  - algorithm
  - leetcode

---

<!--more-->

# 每日一题

## [86. 分隔链表](https://leetcode-cn.com/problems/partition-list/)

```c++
class Solution {
public:

    ListNode* partition(ListNode* head, int x) {
        ListNode* h1 = new ListNode(0);
        h1->next = head;
        ListNode *t1 = h1;

        //t1->next找到第一个大于等于x的节点
        while(t1->next && t1->next->val < x) t1 = t1->next;

        //将所有小于x的节点插入到t1后面
        ListNode* t2 = t1;
        while(t2 && t2->next){
            if(t2->next->val < x){
                ListNode* q = t2->next;
                t2->next = t2->next->next;
                q->next = t1->next;
                t1->next = q;
                t1 = t1->next;
            }else //如果发生了修改，实际上已经发生了对t2->next的更新
                t2 = t2->next;
        }
        
        return h1->next;
    }
};
/*
执行用时：8 ms, 在所有 C++ 提交中击败了58.78%的用户
内存消耗：7 MB, 在所有 C++ 提交中击败了64.16%的用户

相当于一个in-place变换，多出来的时间应该是维护内部结构的操作
**/
```

```c++
class Solution {
public:
    ListNode* partition(ListNode* head, int x) {
        ListNode *h1 = new ListNode(0), *t1 = h1;
        ListNode *h2 = new ListNode(0), *t2 = h2;

        while(head){
            if(head->val < x){
                t1->next = head;
                t1 = t1->next;
            }else{
                t2->next = head;
                t2 = t2->next;
            }
            head = head->next;
        }
        t2->next = NULL;
        t1->next = h2->next;
        return h1->next;
    }
};
/*
用两个指针分别指向较小和较大，忽略对原链表的维护
**/
```

> 2021/1/3

## [509. 斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/)

```c++
class Solution {
public:
    int fib(int n) {
        int a=0, b=1, c;
        if(n==0) return a;
        else if(n==1) return b;
        else{
            while(n>=2){
                c=a+b;
                a=b;
                b=c;
                n--;
            }
            return c;
        }
    }
};
/*就这**/
```

或者

```c++
class Solution {
public:
    int fib(int n) {
        if(n<2) 
            return n;
        else{
            int a=0, b=1, c;
            while(n-->1){
                c=b;
                b+=a;
                a=c;
            }
            return b;
        }
    }
};
```

> 2021/1/4

#### [830. 较大分组的位置](https://leetcode-cn.com/problems/positions-of-large-groups/)

```c++
class Solution {
public:
    //找到每一个不同的分组的起始点并重新计数
    vector<vector<int>> largeGroupPositions(string s) {
        int start=0, cnt=1;
        char pre='\0';
        vector<vector<int> > res;
        for(int i=0; i<=s.size(); i++){
            if(s[i] != pre || i==s.size()){
                if(cnt >= 3){
                    res.push_back({start, start+cnt-1});
                }
                start = i; cnt=1; pre = s[i];
            }else{
                cnt++;
            }
            
        }
        return res;
    }
};
/* 96% **/
```

另解，双指针

```c++
class Solution {
public:
    vector<vector<int>> largeGroupPositions(string s) {
        vector<vector<int> > res;
        int i=0, j=0;
        for(; j<=s.size(); j++){
            if(s[i] != s[j]){
                if(j-i>=3)
                    res.push_back({i, j-1});
                i=j;
            }
        }
        return res;
    }
};
/* 100% **/
```

> 2021/1/5

## [399. 除法求值](https://leetcode-cn.com/problems/evaluate-division/)

```c++
class Solution {
public:

    struct Edge{
        string variable;
        double value;
        Edge* next;
        Edge(string variable, double value, Edge* next=NULL)
            :variable(variable), value(value), next(next){}
    };

    struct Tmp{
        string arg;
        double res;
        Tmp(string arg, double res=1):arg(arg), res(res){}
    };

    void appendEdge(map<string, Edge* >& m, string arg1, string arg2, double value){
        if(!m[arg1]){ //如果节点不存在
            m[arg1] = new Edge(arg2, value);
        }else{
            Edge* head = m[arg1];
            while(head->next) head = head->next;
            head->next = new Edge(arg2, value);
        }
    }

    void buildGraph(map<string, Edge* >& m, vector<vector<string> >& equations, vector<double>& values){
        for(int i=0; i<equations.size(); i++){
            string arg1 = equations[i][0], arg2 = equations[i][1];
            appendEdge(m, arg1, arg2, values[i]);
            appendEdge(m, arg2, arg1, 1/values[i]);
        }
    }

    double bfs(map<string, Edge* >& m, string& arg1, string& arg2){
        map<string, bool> vis;
        queue<Tmp> q; 
        q.push(Tmp(arg1)); vis[arg1]=true;
        while(!q.empty()){
            Tmp cur = q.front(); q.pop();
            if(cur.arg == arg2) return cur.res;
            Edge* head = m[cur.arg];;
            while(head){ 
                if(!vis[head->variable]){
                    q.push(Tmp(head->variable, cur.res*head->value));
                    vis[head->variable] = true;
                }
                head = head->next;
            }
        }
        return -1;
    }

    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {
        vector<double> res;
        map<string, Edge* > m; buildGraph(m, equations, values);
        for(int i=0; i<queries.size(); i++){
            string arg1 = queries[i][0], arg2 = queries[i][1];
            if(!m[arg1] || !m[arg2]) 
                res.push_back(-1);
            else
                res.push_back(bfs(m, arg1, arg2));
        }
        return res;
    }
};
/* 64.5% **/
```

我麻了。

大概思路就是将这个二维数组转化为图，然后通过图的bfs搜索出答案。所以下一步优化应该是如何直接bfs

看了看题解，一解是如此，二解是Floyd，感觉复杂度挺高，三解是带权并查集，来试试。

#### [547. 省份数量](https://leetcode-cn.com/problems/number-of-provinces/)

分类：图、并查集

```c++
class Solution {
public:
    int root(int* u, int j){ //找到j的集合根 
        while(j != u[j]) j = u[j];
        return j;
    }

    void combine(int* u, int i, int j){ //把j接到i上 
        u[root(u, j)] = root(u, i); 
    }

    int findCircleNum(vector<vector<int>>& isConnected) {
        int n = isConnected.size();
        int* u = new int[n];
        for(int i=0; i<n; i++) u[i]=i;

        for(int i=0; i<n-1; i++){
            for(int j=i+1; j<n; j++){
                if(isConnected[i][j]) combine(u, i, j);
            }
        }

        set<int> s;
        for(int i=0; i<n; i++) s.insert(root(u, i));
        return s.size();

    }
};
/* 91.5% **/
```

错误1，两个集的合并应该是根进行合并，而不是单个点的合并

优化。不使用辅助set怎么判断集合个数？根等于自己代表这是集合的顶部，数出来就有几个集合。

`for(i range n) if(u[i] == i) cnt++;`