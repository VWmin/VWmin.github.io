---
title: Leetcode - 每日一题
tag:
  - algorithm
  - leetcode

---

<!--more-->

# 每日一题

## [86. 分隔链表](https://leetcode-cn.com/problems/partition-list/)

```c++
class Solution {
public:

    ListNode* partition(ListNode* head, int x) {
        ListNode* h1 = new ListNode(0);
        h1->next = head;
        ListNode *t1 = h1;

        //t1->next找到第一个大于等于x的节点
        while(t1->next && t1->next->val < x) t1 = t1->next;

        //将所有小于x的节点插入到t1后面
        ListNode* t2 = t1;
        while(t2 && t2->next){
            if(t2->next->val < x){
                ListNode* q = t2->next;
                t2->next = t2->next->next;
                q->next = t1->next;
                t1->next = q;
                t1 = t1->next;
            }else //如果发生了修改，实际上已经发生了对t2->next的更新
                t2 = t2->next;
        }
        
        return h1->next;
    }
};
/*
执行用时：8 ms, 在所有 C++ 提交中击败了58.78%的用户
内存消耗：7 MB, 在所有 C++ 提交中击败了64.16%的用户

相当于一个in-place变换，多出来的时间应该是维护内部结构的操作
**/
```

```c++
class Solution {
public:
    ListNode* partition(ListNode* head, int x) {
        ListNode *h1 = new ListNode(0), *t1 = h1;
        ListNode *h2 = new ListNode(0), *t2 = h2;

        while(head){
            if(head->val < x){
                t1->next = head;
                t1 = t1->next;
            }else{
                t2->next = head;
                t2 = t2->next;
            }
            head = head->next;
        }
        t2->next = NULL;
        t1->next = h2->next;
        return h1->next;
    }
};
/*
用两个指针分别指向较小和较大，忽略对原链表的维护
**/
```

> 2021/1/3

## [509. 斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/)

```c++
class Solution {
public:
    int fib(int n) {
        int a=0, b=1, c;
        if(n==0) return a;
        else if(n==1) return b;
        else{
            while(n>=2){
                c=a+b;
                a=b;
                b=c;
                n--;
            }
            return c;
        }
    }
};
/*就这**/
```

或者

```c++
class Solution {
public:
    int fib(int n) {
        if(n<2) 
            return n;
        else{
            int a=0, b=1, c;
            while(n-->1){
                c=b;
                b+=a;
                a=c;
            }
            return b;
        }
    }
};
```

> 2021/1/4

#### [830. 较大分组的位置](https://leetcode-cn.com/problems/positions-of-large-groups/)

```c++
class Solution {
public:
    //找到每一个不同的分组的起始点并重新计数
    vector<vector<int>> largeGroupPositions(string s) {
        int start=0, cnt=1;
        char pre='\0';
        vector<vector<int> > res;
        for(int i=0; i<=s.size(); i++){
            if(s[i] != pre || i==s.size()){
                if(cnt >= 3){
                    res.push_back({start, start+cnt-1});
                }
                start = i; cnt=1; pre = s[i];
            }else{
                cnt++;
            }
            
        }
        return res;
    }
};
/* 96% **/
```

另解，双指针

```c++
class Solution {
public:
    vector<vector<int>> largeGroupPositions(string s) {
        vector<vector<int> > res;
        int i=0, j=0;
        for(; j<=s.size(); j++){
            if(s[i] != s[j]){
                if(j-i>=3)
                    res.push_back({i, j-1});
                i=j;
            }
        }
        return res;
    }
};
/* 100% **/
```

> 2021/1/5

## [399. 除法求值](https://leetcode-cn.com/problems/evaluate-division/)

```c++
class Solution {
public:

    struct Edge{
        string variable;
        double value;
        Edge* next;
        Edge(string variable, double value, Edge* next=NULL)
            :variable(variable), value(value), next(next){}
    };

    struct Tmp{
        string arg;
        double res;
        Tmp(string arg, double res=1):arg(arg), res(res){}
    };

    void appendEdge(map<string, Edge* >& m, string arg1, string arg2, double value){
        if(!m[arg1]){ //如果节点不存在
            m[arg1] = new Edge(arg2, value);
        }else{
            Edge* head = m[arg1];
            while(head->next) head = head->next;
            head->next = new Edge(arg2, value);
        }
    }

    void buildGraph(map<string, Edge* >& m, vector<vector<string> >& equations, vector<double>& values){
        for(int i=0; i<equations.size(); i++){
            string arg1 = equations[i][0], arg2 = equations[i][1];
            appendEdge(m, arg1, arg2, values[i]);
            appendEdge(m, arg2, arg1, 1/values[i]);
        }
    }

    double bfs(map<string, Edge* >& m, string& arg1, string& arg2){
        map<string, bool> vis;
        queue<Tmp> q; 
        q.push(Tmp(arg1)); vis[arg1]=true;
        while(!q.empty()){
            Tmp cur = q.front(); q.pop();
            if(cur.arg == arg2) return cur.res;
            Edge* head = m[cur.arg];;
            while(head){ 
                if(!vis[head->variable]){
                    q.push(Tmp(head->variable, cur.res*head->value));
                    vis[head->variable] = true;
                }
                head = head->next;
            }
        }
        return -1;
    }

    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {
        vector<double> res;
        map<string, Edge* > m; buildGraph(m, equations, values);
        for(int i=0; i<queries.size(); i++){
            string arg1 = queries[i][0], arg2 = queries[i][1];
            if(!m[arg1] || !m[arg2]) 
                res.push_back(-1);
            else
                res.push_back(bfs(m, arg1, arg2));
        }
        return res;
    }
};
/* 64.5% **/
```

我麻了。

大概思路就是将这个二维数组转化为图，然后通过图的bfs搜索出答案。所以下一步优化应该是如何直接bfs

看了看题解，一解是如此，二解是Floyd，感觉复杂度挺高，三解是带权并查集，来试试。

> 2021/01/06

#### [547. 省份数量](https://leetcode-cn.com/problems/number-of-provinces/)

分类：图、并查集

```c++
class Solution {
public:
    int root(int* u, int j){ //找到j的集合根 
        while(j != u[j]) j = u[j];
        return j;
    }

    void combine(int* u, int i, int j){ //把j接到i上 
        u[root(u, j)] = root(u, i); 
    }

    int findCircleNum(vector<vector<int>>& isConnected) {
        int n = isConnected.size();
        int* u = new int[n];
        for(int i=0; i<n; i++) u[i]=i;

        for(int i=0; i<n-1; i++){
            for(int j=i+1; j<n; j++){
                if(isConnected[i][j]) combine(u, i, j);
            }
        }

        set<int> s;
        for(int i=0; i<n; i++) s.insert(root(u, i));
        return s.size();

    }
};
/* 91.5% **/
```

错误1，两个集的合并应该是根进行合并，而不是单个点的合并

优化。不使用辅助set怎么判断集合个数？根等于自己代表这是集合的顶部，数出来就有几个集合。

`for(i range n) if(u[i] == i) cnt++;`

> 2021/01/07

#### [189. 旋转数组](https://leetcode-cn.com/problems/rotate-array/)

分类:

- 数组

数组循环移位经典题

```c++
class Solution { // 翻转数组
public:
    void reverse(vector<int>& nums, int i, int j){
        int t;
        while(i < j){
            t = nums[i];
            nums[i++] = nums[j];
            nums[j--] = t;
        }
    }
    void rotate(vector<int>& nums, int k) {
        int n = nums.size();
        k = k % n; // 处理当k大于数组长度的情况
        reverse(nums, 0, n-k-1);
        reverse(nums, n-k ,n-1);
        reverse(nums, 0, n-1);
    }
};
/* 17% **/
/* i++; j--; 拿到外面来就是98% 迷惑**/
```

```c++
class Solution { // 复制数组
public:
    void rotate(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> res(n);
        for(int i=0; i<n; i++){
            res[(i+k)%n] = nums[i];
        }
        nums = res;
    }
};/* 50% **/
```

还有一种，记录被覆盖位置，交换

> 2021/01/08

#### [123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)

分类:

- dp

我以为是动态规划之实际上是暴力

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        vector<vector<int>> dp(n, vector<int>(n, 0));
        // 记录区间[i, j]上的最小值最大值，以使dp[i][j]=该区间上的最大差
        int sum = 0;
        for(int i=0; i<n; i++){
            int _min = prices[i], _max = 0;
            dp[i][i] = _max;
            for(int j=i+1; j<n; j++){
                int diff = prices[j] - _min;
                _max = max(_max, diff);
                dp[i][j] = _max;
                _min = min(_min, prices[j]);
            }
            sum = max(dp[0][i] + dp[i][n-1], sum);
        }
        return sum;
    }
};
/* O(n^2) TLE **/
```

动态规划。第`i`结束时，存在4中产生利润变动的操作：

* 第一次购入股票`buy1`
* 第一次卖出股票`sell1`
* 已经卖出一次的前提下，第二次购入股票`buy2`
* 第二次卖出股票`sell2`

对于每一种操作，动态记录操作后的最大利润，那么就有第`i+1`天的最大利润为：（看代码）

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int ini = -prices[0];
        int buy1 = ini, sell1 = 0;
        int buy2 = ini, sell2 = 0;
        for(int i=1; i<prices.size(); i++){
            buy1  = max(buy1, -prices[i]);
            sell1 = max(sell1, buy1+prices[i]);
            buy2  = max(buy2, sell1-prices[i]);
            sell2 = max(sell2, buy2+prices[i]);
        }
        return sell2;
    }
};/* 71% **/
```

> 2021/01/09

#### [228. 汇总区间](https://leetcode-cn.com/problems/summary-ranges/)

分类：

- 数组

简单题，但是边界条件挺细节，特别是c++，还要额外注意int的边界，不然 `nums[i] == nums[i-1] + 1`会overflow

```c++
class Solution {
public:
    vector<string> summaryRanges(vector<int>& nums) {
        vector<string> res;
        if(nums.size() == 0) return res;
        int start = 0;
        for(int i=1; i<nums.size()+1; i++){ // 最后多一次循环来进行扫尾
            if(i<nums.size() && nums[i] == nums[i-1] + 1) continue;
            else{
                res.push_back(
                    i-1 == start
                        ? to_string(nums[start])
                        : to_string(nums[start]) + "->" + to_string(nums[i-1])
                );
                start = i;
            }
        }
        
        return res;
    }
};
```

> 2021/01/10

#### [1202. 交换字符串中的元素](https://leetcode-cn.com/problems/smallest-string-with-swaps/)

分类：图、并查集

同一个连通分量内的字符可任意交换，故各分量内部排序再放回原本位置

```c++
class Solution {
public:
    int root(int *u, int p){
        if (p != u[p])
            u[p] = root(u, u[p]); //路径压缩优化
        return u[p];
    }

    void connect(int *u, int i, int j){
        u[root(u, j)] = root(u, i);
    }

    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {
        int *u = new int[s.size()];
        for(int i=0; i<s.size(); i++) u[i] = i;
        for(int i=0; i<pairs.size(); i++){
            connect(u, pairs[i][0], pairs[i][1]);
        }

        priority_queue<char, vector<char>, greater<char> > qs[s.size()];
        for(int i=0; i<s.size(); i++){
            int indexOfSet = root(u, i);
            qs[indexOfSet].push(s[i]);
        }
        
        string res;
        for(int i=0; i<s.size(); i++){
            int indexOfSet = root(u, i);
            res.push_back(qs[indexOfSet].top());
            qs[indexOfSet].pop();
        }

        delete[] u;

        return res;

    }
};/* 12% **/
```

> 2021/01/11

#### [1203. 项目管理](https://leetcode-cn.com/problems/sort-items-by-groups-respecting-dependencies/)

分类：图、拓扑排序

这题不会，照着题解做的

一个组有一些任务，没有被发配组的任务假设由从`m`开始递增的唯一组接手（如果不存在没有被分配组的任务，那么这些组接手的任务数量为0，总保持组的数量与任务数量相等）。由于任务与任务存在前后依赖，且同一组的任务需要排在一起。所以通过任务之间的依赖关系形成组之间的依赖关系。

故，先对组进行拓扑排序，再依次对组所拥有的任务进行拓扑排序，即为结果

```c++
class Solution {
public:

    vector<int> topSort(vector<int>& degree, vector<vector<int> >& graph, vector<int>& ids){
        queue<int> q;
        vector<int> res;
    
        for(int i : ids)
            if(degree[i] == 0) q.push(i);

        while(!q.empty()){
            int cur = q.front(); q.pop(); res.push_back(cur);
            for(int next : graph[cur])
                if(--degree[next] == 0) q.push(next);
        }
       
        return res.size() == ids.size() ? res : vector<int>();       
    }

    vector<int> sortItems(int n, int m, vector<int>& group, vector<vector<int>>& beforeItems) {
        vector<int> res;
        //组到任务的映射
        vector<vector<int> > group2Item(n+m);
        //初始化图
        vector<vector<int> > groupGraph(n+m);
        vector<vector<int> > itemGraph(n);
        vector<int> groupDegree(n+m, 0);
        vector<int> itemDegree(n, 0);

        //给没有被分配的组分配一个不重复的组，初始化组到任务的映射
        int leftGroup = m;
        for(int i=0; i<n; i++){
            if(group[i] == -1) group[i] = leftGroup++;
            group2Item[group[i]].emplace_back(i);            
        }
        //初始化任务的图
        for(int curItem=0; curItem<beforeItems.size(); curItem++){
            int curGroup = group[curItem];
            for(int beforeItem : beforeItems[curItem]){
                int beforeGroup = group[beforeItem];
                if(curGroup==beforeGroup){ //同一组内任务的依赖关系
                    itemGraph[beforeItem].emplace_back(curItem);
                    itemDegree[curItem] += 1;
                }else{ //不同组之间的依赖关系
                    groupGraph[beforeGroup].emplace_back(curGroup);
                    groupDegree[curGroup] += 1;
                }
            }
        }
        

        //组间拓扑排序
        vector<int> groupIds(n+m); for(int i=0; i<n+m; i++) groupIds[i]=i;
        vector<int> groupTopSort = topSort(groupDegree, groupGraph, groupIds);
        
        if (groupTopSort.size() == 0) return vector<int>();
        //组内拓扑排序
        for(int groupId : groupTopSort){
            int size = group2Item[groupId].size();
            if(size == 0) continue;
            vector<int> groupItemTopSort = topSort(itemDegree, itemGraph, group2Item[groupId]);
            
            if(groupItemTopSort.size() == 0) return vector<int>();
            for(int item : groupItemTopSort) res.push_back(item);
        }
        return res;
    }
};
/* 42% */
```

> 2021/01/12