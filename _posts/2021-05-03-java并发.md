---
title: JAVA并发
tag:
  - java

---

[TOC]

# 并发

## 进程&线程

### 进程

* 程序由指令和数据组。指令加载至CPU，数据加载至内存，另外还可能需要用到其他设备如磁盘。进程即用来加载指令、管理内存、管理IO
* 程序被运行（从磁盘加载程序代码到内存），就开启一个进程
* 进程可以视为程序的一个实例，大部分程序可以同时运行多个进程（程序多开）

### 线程

* 一个进程之内可分一到多个线程
* 一个线程就是一个指令流，将指令流中的一条条指令顺序交给CPU执行
* java中，线程时最小调度单位，进程是最小资源分配单位。windows中进程不活动，作为线程的容器

### 对比

* 进程基本相互独立；线程存在与进程内，是其子集
* 进程拥有共享的资源，如内存空间等，供内部的线程共享
* 进程通信比较复杂
* 线程通信因为共享内存，比较简单
* 线程的上下文切换成本更低

### 并发

微观串行，进程轮流使用CPU，concurrent

### 并行

多核CPU，parallel

### 应用

* 同步，需要等待结果返回才能继续运行
* 异步，不需要等待就能继续运行

*tip：同步另有让多个线程步调一致的意思*

### 结论

1. 单核cpu下，多线程不能实际提高程序计算效率，只是为了能够在不同的任务之间切换，不同线程轮流使用cpu，不至于一个线程总占cpu，别的线程没法干活
2. 多核cpu可以并行跑多个线程，能否提高效率在于任务设计拆分，参考【阿姆达尔定律】
3. IO不占用cpu，但是线程等待IO称为【阻塞IO】。后有改进的【非阻塞IO】、【异步IO】

## Java线程

### 五种状态

创建、就绪、运行、阻塞、终止

### 六种状态（Thread.State）

`NEW` `RUNNABLE` `BLOCKED` `WAITING` `TIMED_WAITING` `TERMINATED`

### 创建和运行线程

#### 方法一 直接使用Thread

```java
Thread t = new Thread() {
	public void run() {
		// some things
	}
};
t.start();
```

#### 方法二 使用Runnable配合Thread

```java
Runnable runnable = () -> {...};
Thread t = new Thread(runnable);
t.start();
```

线程与任务分离；更容易与线程池等API配合；任务类脱离Thread继承体系，更灵活

#### 方法三 FutureTask配合Thread

FutureTask接收Callable类型参数，处理有返回结果的情况

```java
FutureTask<Integer> task = new FutureTask<>(() -> {
    log.info("Future Task running...");
    Thread.sleep(1000);
    return 100;
});

Thread t = new Thread(task, "t1");

task.get(); 
```

### 查看进程线程的方法

#### windows

* 任务管理器可以查看进程和线程数
* `tasklist` `taskkill`

#### Linux

* `ps -fe`查看所有进程
* `ps -fT -p <PID>`查看某个进程的所有线程
* `kill` 关闭进程
* `top`按大写H切换是否显示线程
* `top -H -p <PID>`查看某个进程的所有线程

Java

* `jps`查看所有java进程
* `jstask <PID>`查看某个java进程的所有线程状态
* `jconsle`查看某个Java进程中线程的运行情况

### 线程运行原理

#### 栈&栈帧

JVM由堆、栈、方法区组成；线程使用栈

* 栈有多个栈帧，对应着每次方法调用时所使用的内存
* 每个线程只能有一个活动栈帧，对应正在执行的方法

多线程时，各线程的栈帧独立

#### 上下文切换

因为一下一些原因CPU不再运行当前线程，转而执行另一个线程的代码：

* 线程时间片到
* 垃圾回收
* 有更高级的线程需要运行
* 线程自己调用了sleep、yield、wait、park、synchronized、lock等方法

当上下文切换发生时，由操作系统保存当前线程的状态，并恢复另一个线程的状态。java中程序计数器完成这个操作，记住下一条jvm指令的执行地址，等

频繁的上下文切换会影响性能

### 常见线程方法

![1620309114491](../assets/2021-05-03-java并发.assets/1620309114491.png)

![1620309208406](../assets/2021-05-03-java并发.assets/1620309208406.png)

![1620309252897](../assets/2021-05-03-java并发.assets/1620309252897.png)

### `start` & `run`

直接调用Thread对象的run方法，不会开启新的线程，而是在当前线程执行

### `sleep` & `yield`

#### **sleep**

* 线程会从Running进入Timed Waiting状态（阻塞）
* 线程睡眠中可被调用interrupt打断，抛出InterruptException
* 睡眠结束的线程未必立刻得到执行
* 建议使用`TimeUnit.sleep()`代替`Thread.sleep()`，可读性好点

#### **yield**

* 调用yield的线程会让出当前CPU，从Running进入Runnable（就绪）

#### **线程优先级**

* 线程优先级提示（hint）调度器优先调度该线程，具体由调度器决定
* 如果cpu忙，较高优先级线程可能获得更多时间片；如果闲，优先级没啥用

#### *案例：防止CPU100%*

##### sleep实现

在没有利用cpu来计算时，不要让while(1)空转浪费cpu，这是可以用yield或sleep来让出cpu的使用权给其他程序

```java
//在while(1)中
sleep(50); //一个较短的时间，仅是为了让出cpu防止空转
```

适用于无需锁同步的场景

### `jion`方法

考虑如下情况，r无法获得更新后的值

```java
static int r = 0;
public static void main(String[] args) throws InterruptedException {
    test();
}
private static void test() throws InterruptedException {
    Thread t1 = new Thread(() -> {
        sleep(1);
        r = 10;
    }, "t1");
    t1.start();
    log.info("r: {}", r);
}
```

```java
t1.start();
t1.jion();
log.info("r: {}", r);
```

主线程进行到jion时阻塞，等待t1线程执行完毕

### `interrupt`方法

打断阻塞状态（sleep、wait、join），打断后打断标记其实是false

打断正常运行线程，线程不会直接停止，打断标记会变成true

#### 两阶段终止模式 （Two Phase Termination）

`stop()`直接杀死线程，如果线程拿了锁，就没机会释放

样例：一个可中止的系统状态监控程序

![1620369390030](../assets/2021-05-03-java并发.assets/1620369390030.png)

#### 打断park线程

`LockSupport.park()`

打断parking线程，打断标记变为true；当打断标记已为true时，调用park将不会再停止

`Tread.interrupted()` 返回当前打断标记，然后将其置为false

### 主线程与守护线程

默认情况下，Java进程需要的等待所有线程运行结束才会结束。有一种特殊的线程叫守护线程，只要其他非守护线程全部结束，即使守护线程仍在进行，也会强制结束

```java
public static void main(String[] args) throws InterruptedException {
    Thread t1 = new Thread(() -> {
        while (true) {
            if (Thread.currentThread().isInterrupted()) {
                break;
            }
        }
        log.info("t1 结束");
    }, "t1");
    
    t1.setDaemon(true);
    t1.start();

    TimeUnit.SECONDS.sleep(1);
    log.info("main 结束");
}
```

GC是守护线程

守护线程的守护含义是？

## 共享模型-管程

### 多线程下使用共享变量的问题

如果对共享变量的读写不具有原子性，一个线程的结果可能因为线程切换没来得及写入（指令交错），当再切换回时进行的写入会覆盖其他线程的原子操作

对共享资源的多线程读写操作代码块，称为**临界区**

多个线程在临界区内执行，由于代码的**执行顺序不同**而导致结果无法预测，称之为发生了**竞态条件**

### 避免临界区的竞态条件发生

* 阻塞式：synchronized，Lock
* 非阻塞式：原子变量

### synchronized-互斥

即对象锁

语法

```java
synchronized(obj){
    // 临界区
}
```

```java
synchronized void fun(){...}
//等价于
void fun(){
    synchronized(this){...}
}

synchronized static void fun(){...}
//等价于
static void fun(){
    synchronized(Clazz.class){...}
}
```

### 变量的线程安全分析

#### 成员变量和静态变量

*  没有共享，线程安全
* 读共享，线程安全
* 读写共享，需要考虑

#### 局部变量

* 局部变量线程安全
* 局部变量引用的对象
  * 该对象没有逃离方法的作用范围，线程安全
  * 该对象逃离方法的作用范围，需要考虑

局部变量

```java
public static void test(){
	int i = 10;
	i++;
}
```

局部变量在栈帧中各自创建，不存在共享

局部变量引用

```java
public class TestThreadUnsafe {
    public static void main(String[] args) {
        ThreadUnsafe test = new ThreadUnsafe();

        new Thread(test::fun, "Thread-1").start();
        new Thread(test::fun, "Thread-2").start();
    }
}

class ThreadUnsafe{
    List<Object> list = new ArrayList<>();

    public void fun(){
        for (int i=0; i<1000; i++){
            add();
            remove();
        }
    }

    private void add() {
        list.add(new Object());
    }

    private void remove() {
        list.remove(0);
    }
}
```

两个线程引用了同一个对象，增减操作不具备原子性，线程不安全

### 常见线程安全类

`String`、`Integer`、`StringBuffer`、`Random`、`Vector`、`HashTable`、`java.util.concurrent`

具体指，当多个线程调用这些类的一个实例时，是线程安全的，即方法具有原子性

但，多个方法的组合不是原子性的，如`if(table.get("key") == null) {table.put("key", "value")}`

`String`、`Integer`等不可变类，在修改时实际返回的是新对象的引用

不可变类的修饰通常为`final`就是为了防止被继承破坏不可变的特性

### Monitor概念

#### Java对象头

普通对象

```ruby
Object Header (64btis)
Mark Word (32bits) | klass Word (32bits)
```

数组对象

```ruby
Object Header (64btis)
Mark Word (32bits) | Klass Word (32bits) | Array Length (32bits)
```

Mark Word结构

![1620398358830](../assets/2021-05-03-java并发.assets/1620398358830.png)

*tip：每一行代表MarkWord所处的一种状态*

#### Monitor（锁）

监视器 or 管程

每个Java对象都可以关联一个Monitor对象，如果使用`synchronized`给对象上锁（重量级）之后，该对象头的`Mark Word`中就被设置指向`Monitor`对象的指针（进入重量级锁状态）

Monitor结构如图

![1620398805498](../assets/2021-05-03-java并发.assets/1620398805498.png)

线程执行到临界区时，通过上锁对象去发现其指向的Monitor

* 初始Monitor的Owner为null
* 线程1进入临界区，将Owner值为线程1
* 线程2、线程3进入临界区，进入EntryList指向队列，进入BLOCKED状态
* 线程1执行完临界区，让出Owner，Monitor通知EntryList，阻塞进程自行竞争
* WaitSet中存放获得过锁，但资源条件不满足而进入WAITING状态到的线程

